// Advanced Exploit Scenario Testing
// Comprehensive security testing covering real-world attack vectors
// Tests privilege escalation, token replay, PII leaks, and injection attacks

import { rbacEngine } from '@/lib/auth/rbac-engine';
import { TEST_USERS, TEST_REGIONS, TEST_CASES, EXPLOIT_TEST_SCENARIOS } from '../setup/test-users-data';
import { getTestEnvironmentConfig, SECURITY_TEST_VECTORS } from '../setup/environment-config';

describe('Advanced Exploit Scenario Testing', () => {
  const testConfig = getTestEnvironmentConfig();

  beforeAll(() => {
    process.env.JWT_SECRET = testConfig.jwt.secret;
    process.env.NODE_ENV = 'test';
  });

  describe('Token Replay Attack Prevention', () => {
    it('should prevent cross-region token replay attacks', async () => {
      const manilaUser = TEST_USERS.find(u => u.id === 'usr-ground-ops-001')!; // Manila only
      
      // Legitimate access to Manila
      const legitimateResult = await rbacEngine.evaluatePolicy({
        user: manilaUser,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'assign_driver',
        context: { 
          channel: 'ui', 
          mfaPresent: false,
          ipAddress: '203.177.1.100', // Manila IP
          sessionId: 'sess-manila-001'
        }
      });
      
      expect(legitimateResult.decision).toBe('allow');
      
      // Replay attack: using same token in Cebu
      const replayAttackResult = await rbacEngine.evaluatePolicy({
        user: manilaUser, // Same user/token
        resource: { 
          regionId: TEST_REGIONS.CEBU, // Different region
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'assign_driver',
        context: { 
          channel: 'ui', 
          mfaPresent: false,
          ipAddress: '122.52.1.100', // Cebu IP
          sessionId: 'sess-manila-001', // Same session ID
          suspiciousActivity: {
            tokenReuse: true,
            regionMismatch: true,
            ipGeolocationJump: true
          }
        }
      });
      
      expect(replayAttackResult.decision).toBe('deny');
      expect(replayAttackResult.reasons).toContain('Regional access denied');
      expect(replayAttackResult.metadata.securityFlag).toBe('token_replay_attempt');
      expect(replayAttackResult.metadata.riskScore).toBeGreaterThan(8);
    });

    it('should detect impossible travel patterns', async () => {
      const multiRegionUser = TEST_USERS.find(u => u.id === 'usr-risk-investigator-001')!; // Cebu + Davao
      
      // Access from Cebu
      const cebuAccessResult = await rbacEngine.evaluatePolicy({
        user: multiRegionUser,
        resource: { 
          regionId: TEST_REGIONS.CEBU, 
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'case_open',
        context: { 
          channel: 'ui', 
          mfaPresent: true,
          ipAddress: '122.52.1.100', // Cebu IP
          timestamp: Date.now() - 300000 // 5 minutes ago
        }
      });
      
      expect(cebuAccessResult.decision).toBe('allow');
      
      // Impossible travel: access from Davao 2 minutes later
      const impossibleTravelResult = await rbacEngine.evaluatePolicy({
        user: multiRegionUser,
        resource: { 
          regionId: TEST_REGIONS.DAVAO, 
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'case_open',
        context: { 
          channel: 'ui', 
          mfaPresent: true,
          ipAddress: '124.105.1.100', // Davao IP
          timestamp: Date.now() - 120000, // 2 minutes ago
          previousLocation: {
            ip: '122.52.1.100',
            region: TEST_REGIONS.CEBU,
            timestamp: Date.now() - 300000
          }
        }
      });
      
      // Should allow but flag for security review
      expect(impossibleTravelResult.decision).toBe('allow'); 
      expect(impossibleTravelResult.obligations?.securityFlags).toContain('impossible_travel');
      expect(impossibleTravelResult.obligations?.requireSecurityReview).toBe(true);
      expect(impossibleTravelResult.metadata.riskScore).toBeGreaterThan(7);
    });

    it('should prevent session hijacking attempts', async () => {
      const iamAdmin = TEST_USERS.find(u => u.id === 'usr-iam-admin-001')!;
      
      // Legitimate session
      const legitimateSessionResult = await rbacEngine.evaluatePolicy({
        user: iamAdmin,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'confidential', 
          containsPII: true 
        },
        action: 'manage_users',
        context: { 
          channel: 'ui', 
          mfaPresent: true,
          sessionId: 'sess-admin-secure-001',
          userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          ipAddress: '203.177.1.100',
          deviceFingerprint: 'fp-desktop-001'
        }
      });
      
      expect(legitimateSessionResult.decision).toBe('allow');
      
      // Session hijacking attempt: same session, different device characteristics
      const hijackAttemptResult = await rbacEngine.evaluatePolicy({
        user: iamAdmin,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'confidential', 
          containsPII: true 
        },
        action: 'manage_users',
        context: { 
          channel: 'ui', 
          mfaPresent: false, // Hijacker doesn't have MFA
          sessionId: 'sess-admin-secure-001', // Same session ID
          userAgent: 'curl/7.68.0', // Suspicious user agent
          ipAddress: '1.1.1.1', // Different IP
          deviceFingerprint: 'fp-unknown-999', // Different device
          suspiciousActivity: {
            deviceMismatch: true,
            userAgentChange: true,
            ipChange: true,
            missingMFA: true
          }
        }
      });
      
      expect(hijackAttemptResult.decision).toBe('deny');
      expect(hijackAttemptResult.reasons).toContain('MFA required for sensitive operations');
      expect(hijackAttemptResult.metadata.securityFlag).toBe('session_hijack_attempt');
      expect(hijackAttemptResult.obligations?.terminateSession).toBe(true);
    });
  });

  describe('Privilege Escalation Prevention', () => {
    it('should prevent vertical privilege escalation', async () => {
      const groundOpsUser = TEST_USERS.find(u => u.id === 'usr-ground-ops-001')!; // Level 10
      
      // Attempt to perform higher privilege operation
      const escalationAttemptResult = await rbacEngine.evaluatePolicy({
        user: groundOpsUser,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'confidential', 
          containsPII: true 
        },
        action: 'manage_users', // IAM admin level operation
        context: { 
          channel: 'ui', 
          mfaPresent: true // Even with MFA, should be denied
        }
      });
      
      expect(escalationAttemptResult.decision).toBe('deny');
      expect(escalationAttemptResult.reasons).toContain('Missing required permission');
      expect(escalationAttemptResult.metadata.attemptedEscalation).toBe('vertical');
      expect(escalationAttemptResult.metadata.requiredLevel).toBeGreaterThan(groundOpsUser.roles[0].role?.level!);
    });

    it('should prevent horizontal privilege escalation', async () => {
      const supportUser = TEST_USERS.find(u => u.id === 'usr-support-001')!; // Support role
      
      // Attempt to perform operations from different domain (finance)
      const horizontalEscalationResult = await rbacEngine.evaluatePolicy({
        user: supportUser,
        resource: { 
          regionId: TEST_REGIONS.CEBU, 
          dataClass: 'confidential', 
          containsPII: false 
        },
        action: 'approve_payout_batch', // Finance operation
        context: { 
          channel: 'ui', 
          mfaPresent: true
        }
      });
      
      expect(horizontalEscalationResult.decision).toBe('deny');
      expect(horizontalEscalationResult.reasons).toContain('Missing required permission');
      expect(horizontalEscalationResult.metadata.attemptedEscalation).toBe('horizontal');
      expect(horizontalEscalationResult.metadata.crossDomain).toBe('support_to_finance');
    });

    it('should prevent role capability union attacks', async () => {
      const opsMonitor = TEST_USERS.find(u => u.id === 'usr-ops-monitor-001')!; // Level 20, view-only
      
      // Simulate token manipulation to add write permissions
      const manipulatedUser = {
        ...opsMonitor,
        permissions: [
          ...opsMonitor.permissions,
          'assign_driver', // Write permission not in role
          'manage_users', // Admin permission not in role
          'unmask_pii_with_mfa' // PII permission not in role
        ]
      };
      
      // System should validate against role definition, not token claims
      for (const forbiddenPermission of ['assign_driver', 'manage_users', 'unmask_pii_with_mfa']) {
        const unionAttemptResult = await rbacEngine.evaluatePolicy({
          user: manipulatedUser,
          resource: { 
            regionId: TEST_REGIONS.CEBU, 
            dataClass: 'internal', 
            containsPII: false 
          },
          action: forbiddenPermission,
          context: { 
            channel: 'ui', 
            mfaPresent: true
          }
        });
        
        expect(unionAttemptResult.decision).toBe('deny');
        expect(unionAttemptResult.reasons).toContain('Permission not granted by active roles');
        expect(unionAttemptResult.metadata.securityFlag).toBe('role_permission_mismatch');
      }
    });

    it('should prevent debug route privilege escalation', async () => {
      const analystUser = TEST_USERS.find(u => u.id === 'usr-analyst-001')!;
      
      // Attempt to access hidden debug/admin routes
      const debugRoutes = [
        'debug_user_permissions',
        'admin_backdoor_access',
        'system_diagnostic_full',
        'emergency_override_all',
        'god_mode_enable'
      ];
      
      for (const debugRoute of debugRoutes) {
        const debugAccessResult = await rbacEngine.evaluatePolicy({
          user: analystUser,
          resource: { 
            regionId: TEST_REGIONS.NCR_MANILA, 
            dataClass: 'internal', 
            containsPII: false 
          },
          action: debugRoute,
          context: { 
            channel: 'api', 
            mfaPresent: true,
            debugAttempt: true
          }
        });
        
        expect(debugAccessResult.decision).toBe('deny');
        expect(debugAccessResult.reasons).toContain('Debug routes not accessible');
        expect(debugAccessResult.metadata.securityFlag).toBe('debug_route_access_attempt');
      }
    });
  });

  describe('PII Leak Prevention', () => {
    it('should prevent unmasked PII in data exports', async () => {
      const analyst = TEST_USERS.find(u => u.id === 'usr-analyst-001')!; // Masked PII scope
      
      // Attempt to export data with PII fields
      const exportAttemptResult = await rbacEngine.evaluatePolicy({
        user: analyst,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'internal', 
          containsPII: true 
        },
        action: 'export_reports',
        context: { 
          channel: 'api', 
          mfaPresent: false,
          exportFormat: 'csv',
          requestedFields: [
            'driver_id', 'name', 'phone', 'email', 'address', 
            'license_number', 'ssn', 'bank_account', 'rating'
          ],
          includesPII: true
        }
      });
      
      expect(exportAttemptResult.decision).toBe('allow'); // Allow but with masking
      expect(exportAttemptResult.obligations?.maskPII).toBe(true);
      expect(exportAttemptResult.obligations?.maskedFields).toEqual([
        'phone', 'email', 'address', 'license_number', 'ssn', 'bank_account'
      ]);
      expect(exportAttemptResult.obligations?.exportRestrictions).toContain('mask_personal_data');
      
      // Verify zero unmasked PII incidents
      expect(exportAttemptResult.obligations?.preventPIILeak).toBe(true);
    });

    it('should prevent PII leaks through bulk operations', async () => {
      const opsManager = TEST_USERS.find(u => u.id === 'usr-ops-manager-001')!; // Masked PII scope
      
      // Bulk operation with PII data
      const bulkPiiResult = await rbacEngine.evaluatePolicy({
        user: opsManager,
        resource: { 
          regionId: TEST_REGIONS.DAVAO, 
          dataClass: 'internal', 
          containsPII: true 
        },
        action: 'bulk_driver_update',
        context: { 
          channel: 'batch', 
          mfaPresent: false,
          recordCount: 5000,
          fieldsUpdated: ['status', 'phone', 'email', 'address'],
          bulkOperation: true
        }
      });
      
      expect(bulkPiiResult.decision).toBe('allow');
      expect(bulkPiiResult.obligations?.maskPII).toBe(true);
      expect(bulkPiiResult.obligations?.auditLevel).toBe('enhanced');
      expect(bulkPiiResult.obligations?.preventPIILeak).toBe(true);
      expect(bulkPiiResult.metadata.bulkPiiCount).toBe(5000);
    });

    it('should prevent PII leaks through error messages', async () => {
      const groundOpsUser = TEST_USERS.find(u => u.id === 'usr-ground-ops-001')!; // No PII scope
      
      // Attempt operation that might leak PII in error messages
      const piiErrorResult = await rbacEngine.evaluatePolicy({
        user: groundOpsUser,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'internal', 
          containsPII: true 
        },
        action: 'contact_driver_masked',
        context: { 
          channel: 'ui', 
          mfaPresent: false,
          driverId: 'driver-with-sensitive-data-001'
        }
      });
      
      expect(piiErrorResult.decision).toBe('deny');
      expect(piiErrorResult.reasons).toContain('PII access denied - insufficient scope');
      expect(piiErrorResult.metadata.sanitizedError).toBe(true);
      expect(piiErrorResult.reasons).not.toContain('driver-with-sensitive-data-001'); // No PII in error
    });
  });

  describe('Injection Attack Prevention', () => {
    it('should prevent case ID injection attacks', async () => {
      const supportUser = TEST_USERS.find(u => u.id === 'usr-support-001')!;
      
      // Test malicious case IDs
      for (const maliciousCaseId of SECURITY_TEST_VECTORS.CASE_ID_ATTACKS) {
        const injectionResult = await rbacEngine.evaluatePolicy({
          user: supportUser,
          resource: { 
            regionId: TEST_REGIONS.NCR_MANILA, 
            dataClass: 'internal', 
            containsPII: false 
          },
          action: 'case_open',
          context: { 
            channel: 'ui', 
            mfaPresent: false,
            caseId: maliciousCaseId
          }
        });
        
        expect(injectionResult.decision).toBe('deny');
        expect(injectionResult.reasons).toContain('Invalid case ID format');
        expect(injectionResult.metadata.securityFlag).toBe('injection_attempt');
        expect(injectionResult.metadata.sanitizedInput).toBe(true);
      }
    });

    it('should prevent region ID injection attacks', async () => {
      const multiRegionUser = TEST_USERS.find(u => u.id === 'usr-risk-investigator-001')!;
      
      // Test malicious region IDs
      for (const maliciousRegion of SECURITY_TEST_VECTORS.REGION_INJECTION_ATTEMPTS) {
        const regionInjectionResult = await rbacEngine.evaluatePolicy({
          user: multiRegionUser,
          resource: { 
            regionId: maliciousRegion, 
            dataClass: 'internal', 
            containsPII: false 
          },
          action: 'case_open',
          context: { 
            channel: 'ui', 
            mfaPresent: false
          }
        });
        
        expect(regionInjectionResult.decision).toBe('deny');
        expect(regionInjectionResult.reasons).toContain('Invalid region identifier');
        expect(regionInjectionResult.metadata.securityFlag).toBe('injection_attempt');
      }
    });

    it('should prevent permission injection through API parameters', async () => {
      const analyst = TEST_USERS.find(u => u.id === 'usr-analyst-001')!;
      
      // Attempt to inject permissions through API parameters
      const permissionInjectionResult = await rbacEngine.evaluatePolicy({
        user: analyst,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'query_curated_views',
        context: { 
          channel: 'api', 
          mfaPresent: false,
          apiParams: {
            'permission[]': 'manage_users',
            'role': 'admin',
            'escalate': 'true',
            'bypass_check': '1',
            'admin_override': 'enabled'
          }
        }
      });
      
      expect(permissionInjectionResult.decision).toBe('allow'); // Original permission allowed
      expect(permissionInjectionResult.metadata.sanitizedParams).toBe(true);
      expect(permissionInjectionResult.metadata.securityFlag).toBe('parameter_injection_attempt');
      
      // Verify injected permissions are ignored
      expect(permissionInjectionResult.metadata.effectivePermissions).not.toContain('manage_users');
    });
  });

  describe('Temporal Exploit Prevention', () => {
    it('should prevent escalation token time boundary manipulation', async () => {
      const supportUser = TEST_USERS.find(u => u.id === 'usr-support-001')!;
      
      // Create user with manipulated temporary access (extended expiry)
      const manipulatedTempAccessUser = {
        ...supportUser,
        temporaryAccess: [{
          ...supportUser.temporaryAccess![0],
          expiresAt: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year - suspicious
          isActive: true
        }]
      };
      
      const timeManipulationResult = await rbacEngine.evaluatePolicy({
        user: manipulatedTempAccessUser,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'internal', 
          containsPII: false 
        },
        action: 'case_open',
        context: { 
          channel: 'ui', 
          mfaPresent: false,
          caseId: TEST_CASES.SUPPORT_MANILA_001,
          suspiciousActivity: {
            temporalAnomaly: true,
            excessiveEscalationDuration: true
          }
        }
      });
      
      expect(timeManipulationResult.decision).toBe('deny');
      expect(timeManipulationResult.reasons).toContain('Suspicious temporal access pattern');
      expect(timeManipulationResult.metadata.securityFlag).toBe('temporal_manipulation_attempt');
    });

    it('should validate clock skew tolerance limits', async () => {
      const riskInvestigator = TEST_USERS.find(u => u.id === 'usr-risk-investigator-001')!;
      
      // Simulate extreme clock skew
      const clockSkewResult = await rbacEngine.evaluatePolicy({
        user: riskInvestigator,
        resource: { 
          regionId: TEST_REGIONS.CEBU, 
          dataClass: 'restricted', 
          containsPII: true 
        },
        action: 'unmask_pii_with_mfa',
        context: { 
          channel: 'ui', 
          mfaPresent: true,
          mfaTimestamp: Math.floor(Date.now() / 1000) + 3600, // 1 hour in future
          systemTime: Math.floor(Date.now() / 1000),
          clockSkew: 3600 // 1 hour skew
        }
      });
      
      expect(clockSkewResult.decision).toBe('deny');
      expect(clockSkewResult.reasons).toContain('Excessive clock skew detected');
      expect(clockSkewResult.metadata.securityFlag).toBe('time_manipulation_attempt');
      expect(clockSkewResult.obligations?.syncSystemClock).toBe(true);
    });

    it('should prevent backdated audit log manipulation', async () => {
      const auditor = TEST_USERS.find(u => u.id === 'usr-auditor-001')!;
      
      // Attempt to create audit entry with backdated timestamp
      const backdateAuditResult = await rbacEngine.evaluatePolicy({
        user: auditor,
        resource: { 
          regionId: TEST_REGIONS.NCR_MANILA, 
          dataClass: 'confidential', 
          containsPII: false 
        },
        action: 'create_audit_entry',
        context: { 
          channel: 'api', 
          mfaPresent: true,
          auditTimestamp: Math.floor(Date.now() / 1000) - 86400 * 30, // 30 days ago
          currentTimestamp: Math.floor(Date.now() / 1000),
          backdatedEntry: true
        }
      });
      
      expect(backdateAuditResult.decision).toBe('deny');
      expect(backdateAuditResult.reasons).toContain('Backdated audit entries not allowed');
      expect(backdateAuditResult.metadata.securityFlag).toBe('audit_manipulation_attempt');
    });
  });

  describe('Comprehensive Attack Simulation', () => {
    it('should handle coordinated multi-vector attacks', async () => {
      const groundOpsUser = TEST_USERS.find(u => u.id === 'usr-ground-ops-001')!;
      
      // Simulate coordinated attack with multiple vectors
      const coordinatedAttackResult = await rbacEngine.evaluatePolicy({
        user: {
          ...groundOpsUser,
          // Token manipulation
          permissions: [...groundOpsUser.permissions, 'manage_users', 'unmask_pii_with_mfa'],
          allowedRegions: [TEST_REGIONS.NCR_MANILA, '*'], // Region wildcard injection
          piiScope: 'full' // Scope escalation
        },
        resource: { 
          regionId: 'reg-admin-*', // Injection attempt
          dataClass: 'restricted', 
          containsPII: true 
        },
        action: 'admin_backdoor_access', // Debug route
        context: { 
          channel: 'api', 
          mfaPresent: false,
          caseId: 'CASE-ADMIN-*; DROP TABLE users; --', // SQL injection
          sessionId: 'sess-hijacked-001',
          ipAddress: '1.1.1.1', // Suspicious IP
          userAgent: 'curl/7.68.0', // Tool-based access
          suspiciousActivity: {
            multipleVectors: true,
            tokenManipulation: true,
            injectionAttempts: true,
            privilegeEscalation: true,
            debugRouteAccess: true
          }
        }
      });
      
      expect(coordinatedAttackResult.decision).toBe('deny');
      expect(coordinatedAttackResult.reasons).toContain('Multiple security violations detected');
      expect(coordinatedAttackResult.metadata.securityFlags).toContain('coordinated_attack');
      expect(coordinatedAttackResult.metadata.riskScore).toBe(10); // Maximum risk
      expect(coordinatedAttackResult.obligations?.terminateSession).toBe(true);
      expect(coordinatedAttackResult.obligations?.notifySecurityTeam).toBe(true);
      expect(coordinatedAttackResult.obligations?.blockIP).toBe(true);
    });

    it('should maintain security under high load attack', async () => {
      const users = [
        TEST_USERS.find(u => u.id === 'usr-ground-ops-001')!,
        TEST_USERS.find(u => u.id === 'usr-ops-monitor-001')!,
        TEST_USERS.find(u => u.id === 'usr-support-001')!
      ];
      
      // Simulate rapid-fire attack from multiple users
      const attackPromises = [];
      
      for (let i = 0; i < 100; i++) {
        const user = users[i % users.length];
        const promise = rbacEngine.evaluatePolicy({
          user,
          resource: { 
            regionId: SECURITY_TEST_VECTORS.REGION_INJECTION_ATTEMPTS[i % SECURITY_TEST_VECTORS.REGION_INJECTION_ATTEMPTS.length],
            dataClass: 'restricted', 
            containsPII: true 
          },
          action: 'admin_override',
          context: { 
            channel: 'api', 
            mfaPresent: false,
            attackIteration: i,
            highVolumeAttack: true
          }
        });
        attackPromises.push(promise);
      }
      
      const results = await Promise.all(attackPromises);
      
      // All attacks should be denied
      expect(results.every(r => r.decision === 'deny')).toBe(true);
      
      // System should maintain performance under attack
      const evaluationTimes = results.map(r => r.metadata.evaluationTime || 0);
      const avgEvaluationTime = evaluationTimes.reduce((a, b) => a + b, 0) / evaluationTimes.length;
      expect(avgEvaluationTime).toBeLessThan(100); // Should remain fast
      
      // Should detect and flag coordinated attack
      const lastResult = results[results.length - 1];
      expect(lastResult.metadata.securityFlags).toContain('high_volume_attack');
    });
  });
});